fir 1) loops: for (iterate over a sequence e.g,: list, set, tuple, string), while

for i in range(5): --> range index starts from 0.  range(2, number) means 2 to that number.
    print('something')

counter = 0
while counter < 5:
    print('something')
    count += 1


 break, continue.

 2) Super example that python can go and iterate over a matrix:
    matrix = [[1,2,3],[4,5,6],[7,8,9]]

for row in matrix:  # we can say matrix is a list of lists
    for element in row:
        print(element)
        print(element, end= ' ') # By default print will have a new line after a line. But if you want to add a space or custom behaviour you can use the end attibute.
    print()

 3) Functions in geenral. But if those functions in clasess, then we call them as methods.
     arguments vs parameters --> in the functin def name, it is paramteter. arguments are which we pass to function when we are calling them.

     default value in function example:

      def mydata(data, second=2): # second is having the default value so we can say it is an optinal parameter. Also, you need to add first required parameters followed by the optional parameters
        print("I am doing this"+data)
      mydata("jo")
 4) Lists: Ordered, mutable collection of items. // Go throughh the list methods from python documentation.
     Basic operations:
        Accessing elements : list[index]
        Slicing: list[start:end:step] # start is included, but end is excluded. Also check how negative index work in slicing.
        modifying elements: list[index] = new_value
        Adding elements: list.append(item)
        Removing elements: list.remove(item) #This is the value, If you multipe 3's, then it will remove the first 3
                           del list[index]

        List Comprehensions:
           if you have a list, to iterate, you can say:
           for item in first_lsit:
            print(item)

            OR

            for item in range(len(first)list)):
                print(first_list[i]

              OR i want to create a list, that will match a condition.

              new_list = [x for x in second_list if x%2==0] # Go a bit in-depth of this one.


      Important Example for substring:
        haystack = "sadbutsad"
        needle = "sad"
        Now you want to find the first occurence of sad, and print the index of s.
        for i in range(len(haystack)):
            if(haystack[i:i+len(needle)] == needle:
               print(i)
               break

 5) Slicing of List (mutable) and String (immutable)
     The format of the list slicing is [start:stop:step]
     List Slicing example: (The same is applicable to String)
        name = ["sinivassaitala", "ravi", "samu", "hasan", "kalpana"]
        data = name[1:4:1]

      Note: suppose we are printing a name backward, then we can give it as below:
      data = name[len(name)-1::-1]   -> the middle :: says that don't stop anywhere and go upto the end one by one.

  6) Tuples:
     immutable, shimilar to list, but you use () brackets, instead of [] and they are ordered.
     Example:
     my_tuple = (1, "str", 2)  #  For tuple, paranthesis () is optional
      for i in range(len(my_tuple)):
      print(my_tuple[i], end='')

      Also for example if you keep only 1 element in the tuple, it will won't recognize it as a tuple, but it will consider it as a variable.
      Example: my_tuple = (5) # When we give type of my_tuple, it will be an int. you need to keep a , after the value to indicate it as a tuple.

      Tuple packing: Multiple values assigned to a single tuple variable.
      a = (1,4,5)

      Tuple unpacking: Values in a tuple assigned to multiple variables.
      n,m,l = a

      you can convert a list to a tuple .  example a = tuple(my_list)

  7) Sets:
        created using {} or the set() constructor.  Cannot contain duplicate elements and it is unordered and it is mutable.
        cannot access through index.  set.add(item), set.remove(), union, intersection, difference, isSubset, isDisjoint
        Example:
        mydata = {4,5}
        mydata1 = set() // you can pass a tuple, or list or another set into the constructor argument.
        mydata1.add(6)
        print(mydata.union(mydata1))

        set is linear time...means constant time...because it will use hashing to store or getting element.

  8) Dictionary:
      Ordered (3.6 and earlier they (key value pairs) are not ordered - insertion order, but you cannot access elements using index), mutable collection of key-value pairs
      created using {} or the dict() constructor
      Keys must be unique and immutable.

      Example: {Nepal:Kathmandu, Italy:Rome, ....}
          To Access:  dict_1['Nepal']    # you cannot use the index.

      dict_1[key] = value
      dict_1.pop(key) # to remove
      # other methods:  keys(), values(), items() -- (returns a list of tuples...and each tuple is a key value pair)

   9) Python Modules (Example modules (kind of java package): math, random, datetime, os etc)
      Example1:
        import random
        print(random.randint(1,100))

      Example2: (Writing your own module):

      #customer.py
      name = "srinivas"
      def hello(myname):
           print("Hello " + myname)
            return myname
      ########################
      # main.py
      from customer import test, factorial, data #  import a specifics function or variable
      import customer as cus # This is called alias
      print(cus.name)
      print(cus.hello("ravi"))

      #if you import a specific function etc, then you no need to use the class name when calling the function.
      from customer import hello, name
      print(hello("ravi"))
      print(name)

  10) Python Lambda Function  (without having to define name for the function)
      lambda argument(s) : expression
      Example: greet = lambda : print('hello world')
               greet()

      Example2: It is returning the value by default.
      add = lambda x, y:  x + y
      print(add(1, 2))

      Example 3: (if else statement)
      lambda a,b: a + b if a < 3 else a * b # if a less than 3, then return a + b else return a * b

  11) map() function # It's called a high order function - because it's a function that takes another function as an argument.
      The map() function takes two arugments  # This will map every element of the iterable to the function and return a new iterable.
       a) function
       b) iterable - an iterable like sets, lists, tuples etc.

       Example1:
       elm = [2,3,4,5,6]
       ds = lambda arr : map(lambda x : x*x, arr) #It creates the map of elements. In the below line, you are again converting it to iterable again..to print.
       print(list(ds(elm)))

       # instead of n*n you can give it as n**2

  12) filter() function # It's called a high order function - because it's a function that takes another function as an argument.
       The filter() function takes two arugments  # This will filter every element of the iterable to the function and return a new iterable.
       a) function
       b) iterable - an iterable like sets, lists, tuples etc.

       elm = [2,3,4,5,6]
       ds = lambda arr : filter(lambda x : x>2, arr)
       print(list(ds(elm)))

  13) Combine both filter and map
      nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      result = map(lambda x: x * x, filter(lambda x: x % 2 == 0, nums))
      print(list(result))

  14) scopes of python variables - local and global.

      local scope - any variable which is created inside a function can be accessed within that function or block.

      Call by Value vs Call by Reference
      -- Call by Value: a copy of the value is passed to a function (used for immutable objects)
      -- Call by reference: a reference to the original object is passed to a function (used for mutable objects)

      -- call by value example:
         x = 5
        def square(y):
            return x * x
        print(square(5))
        print(x) # The original global variable is not modified.

15) OOPs in Python

    Example1:

    class Dog:
     def bark(self ):   #self is not considered as an attributee. It is something like a this object of class.
        pingpong = "ravi"  # This only creates the local variable and not attached to the object. So, when you access object.pingpong from outside, it will give as pingpong property not defined in this object.
        print("Dog bark")
        self.name = "srinivas"

     myDog = Dog()
     myDog.bark()
     print(self.name) # This dosen't wok because self is only valid inside class methods, where it refers the current object.
     print(myDog.name) # This will work.


15.1) Python constructor and destructor and representation # The name init cannot be changed and it is an inbuilt name for constructor that should be used.
      Example 1:
      class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

     def __del__(self):   # This is a default destructor that is implicit and you can override in any class.
                          # Note: This is called when the garbage collector decides to delete an object. So, it is not garunteed that it is always called when we expect it.
        print("deleting this object")

     def __repr__(self):  # when you print an object you get the non-readable format. In order to print in a readable format, you can use this. This is shimilar to overriding of toString in java
        return "name: "+self.name

    myDog = Dog("ravi", "srinu")
    print(myDog.name)
    print(myDog.age)

15.2)  Define a function that takes an object as an attribute.
     class Dog:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    myDog = Dog("ravi", "srinu")

    def my_function(dog : Dog):
        print(dog.age)

    my_function(myDog)


15.3) It is a good practice to define a variable and declared it's value as None.  This will be a good code, when someone sees that we are initializing to None.

15.4) hasattr(objectName, attribute)   # this inbuilt method will check if an object has specific attribute. It's a boolean.
      setattr(objectName, attribute)
      delattr(objectName, attribute)

16) Oops - Inheritance:
    Example1:
    class Animal:
        def function_animall(self):
            print("Animal")

    class Dog(Animal): # This is how we wil inherit the animal
        def function_dog(self): # if we give function_animall here, then the output will be animal
            print("Dog")

    animal = Dog()
    animal.function_animall() # will print animal


    Example2:

    class Bird:
        def fly(self):
          print("I can fly")

    class Fish:
        def swim(self):
            print("I can swimm")

    class FlyingFish(Bird, Fish): #Multiple inheritance is possible
        pass  # pass is just used so that the class definition is syntactically valid (Python doesnâ€™t allow an empty class or function body).


    ff = FlyingFish()
    ff.fly()
    ff.swim()

    Example 3:

    class Bird:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def move(self):
       print("Move Bird",self.x,self.y,self.z)

class Fish:
   def __init__(self, a, b, c):
       self.a = a
       self.b = b
       self.c = c

class FlyingFish(Bird, Fish):
    def __init__(self, x,y,z, a, b, c, k):
        Fish.__init__(self, a, b, c)
        Bird.__init__(self, x, y, z)
        self.k = k



ff = FlyingFish(1, 2, 3,4,5,6, 0)
print(ff.x, ff.y, ff.z, ff.a, ff.b, ff.c, ff.k)
print(ff.move())

17) oops - Encapsulation

   Example1:

   class Car:
    wheels = 4 # public attribute
    _color = "red" #protected attribute
    __engine = "V8"  #private attribute

    Example2:

    class A:
     def __init__(self):
         self.__a1 = None
         self._a = None

     def myfunc(self):
        self._a = 1
        self.__a1 = 2

    class B(A):
        def mydetails(self):
            print(self.__a1) # This one will be an error as private variables cannot be access outside of the class
            print(self._a) # This can be access as it is protected, if this class extends the other class.

18) oops - Polymorphism

    The ability of different   classes to share the same interface and be treated as objects of a common superclass.
    In python, there is no concept of interface, so, there will the super class and if  a child class extends  this class,
    then it has to override the parent class method.

19) Customer Sort Functions in Python:
     - sorted(): Returns a new sorted list from the specified iterable
     - sort(): Modifies the list in-place and returns None
     - key: Function to be called on each list element to determine the sorting order
     - reverse: if set to True, the list is sorted in descending order.

     Example:
     mylist = ['ab', 'de', 'cf']
     secondlist = sorted(mylist)
     print(secondlist)
     mylist.sort(reverse=True)
     print(mylist)
     thirdlist = sorted(secondlist, key=lambda x: x[1], reverse=True) # second character of a string.
     print(thirdlist)




























